b) In order to store the tasks I used a TreeMap. The map was used to store the task id (String) and the task object. A TreeMap was used because I wanted to insert the tasks in an orderly manner.
I used an array to store the estimates entered by the N number of users.
An arraylist was used to store the tasks before they were written to a file. The array list was used as it was much easier to write to the file, rather than while using a map.

e) Both Strategy pattern and Template Method pattern was used.

Strategy Pattern = This was used to implement the different reconciliation approaches (Three reconciliation strategies).The reason strategy pattern was used was cause there were several algorithms to solve the problem which was what reconciliation approach was going  be used. Therefore, three classes for the three strategies were created. HighestEstimateStragey.java , MedianEstimateStrategy.java and RevisedEstimateStrategy.java were the strategy classes created. They were all implementations of the ConfigureOption.java class interface. Thus they implement that interface. The strategy objects were created in the initLoaders() method in the ConfigureMenu.java file. Each strategy class has its own algorithm to execute a reconciliation approach.

Template Method Pattern - This was used to implement the two menus in the program. The reason this pattern was used was because the algorithm was almost the same except for a few parts. This was implemented using an abstract class called Menu.java and the two sub classes called MainMenu.java and ConfigureMenu.java. The Menu.java has the template method called displayMenu() which is called in both menus. The hook method in the Menu.java file is runMenu(). Since each menu has different options that need to be considered and different ways each of those options are executed. Thus because of the different implementations of the runMenu() function it was considered an abstract hook method.

f) Composite Pattern was used to implement the work breakdown structure tasks. In the workbreakdown structure, tasks can have subtasks and those subtasks can have more subtasks. Thus in order to implement this tree of task objects the composite pattern was used. The composite pattern requires a Node Class , a composite class and a leaf class. The node class in this scenario is the Task.java class ,while the composite class is the CompositeTask.java class and the leaf class is the SubTask.java class. To address the problem description of the assignment tasks which already had an effort estimated and that did not have subtasks were considered to be subtasks. Tasks that did have subtasks and that did not have an estimate were considered as composite tasks. This was because tasks without a effort may have subtasks in the future if the user decides to. When the file is read, a recursive algorithm is used to find the appropriate place of the task in the tree. If the task has a parent task the tree is recursively searched till the composite parent task is found and then added to it's subtasks. 
